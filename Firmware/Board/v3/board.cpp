/*
* @brief Contains board specific variables and initialization functions
*/

#include <board.h>

#include <odrive_main.h>
#include <low_level.h>

#include <Drivers/STM32/stm32_timer.hpp>

#include <adc.h>
#include <dma.h>
#include <tim.h>
#include <usart.h>
#include <freertos_vars.h>

// this should technically be in task_timer.cpp but let's not make a one-line file
bool TaskTimer::enabled = false;

extern "C" void SystemClock_Config(void); // defined in main.c generated by CubeMX

/**
 * 从单片机的中断线中选择一个硬件中断线（硬件中断服务程序入口）作为软件中断线使用，
 * 被使用的中断线不可在作为硬件中断使用。这里我选择使用 USB OTG 模式使用的中断做为软件中断线使用，
 * 因为我们没有 USB OTG 模式，所以这样不会浪费常用的中断。同时使用宏重命名，这样便于理解。
 */
#define ControlLoop_IRQHandler OTG_HS_IRQHandler
#define ControlLoop_IRQn OTG_HS_IRQn

// This array is placed at the very start of the ram (0x20000000) and will be
// used during manufacturing to test the struct that will go to the OTP before
// _actually_ putting anything into OTP. This avoids bulk-destroying STM32's if
// we introduce unintended breakage in our manufacturing scripts.
uint8_t __attribute__((section(".testdata"))) fake_otp[FLASH_OTP_END + 1 - FLASH_OTP_BASE] = {0, 0, 0, HW_VERSION_MAJOR, HW_VERSION_MINOR, HW_VERSION_VOLTAGE};

Stm32SpiArbiter spi3_arbiter{&hspi3};

Drv8301 m0_gate_driver{
    &spi3_arbiter,
    {GPIOC, GPIO_PIN_13}, // M0 nCS
    {}, // EN pin (shared between both motors, therefore we actuate it outside of the drv8301 driver)
    {GPIOD, GPIO_PIN_2} // nFAULT pin (shared between both motors)
};

Drv8301 m1_gate_driver{
    &spi3_arbiter,
    {GPIOC, GPIO_PIN_14}, // M1 nCS
    {}, // EN pin (shared between both motors, therefore we actuate it outside of the drv8301 driver)
    {GPIOD, GPIO_PIN_2} // nFAULT pin (shared between both motors)
};

/*场效应晶体管热敏电阻多项式系数*/
const float fet_thermistor_poly_coeffs[] =
    {363.93910201f, -462.15369634f, 307.55129571f, -27.72569531f};
const size_t fet_thermistor_num_coeffs = sizeof(fet_thermistor_poly_coeffs)/sizeof(fet_thermistor_poly_coeffs[1]);

OnboardThermistorCurrentLimiter fet_thermistors[AXIS_COUNT] = {
    {
        2/*15*/, // adc_channel
        &fet_thermistor_poly_coeffs[0], // coefficients
        fet_thermistor_num_coeffs // num_coeffs
    }, {
        3/*4*/, // adc_channel
        &fet_thermistor_poly_coeffs[0], // coefficients
        fet_thermistor_num_coeffs // num_coeffs
    }
};

OffboardThermistorCurrentLimiter motor_thermistors[AXIS_COUNT];

Motor motors[AXIS_COUNT] = { /*定义电机*/
    {
        &htim1, // timer
        0b110, // current_sensor_mask
        1.0f / SHUNT_RESISTANCE, // shunt_conductance [S]
        m0_gate_driver, // gate_driver
        m0_gate_driver, // opamp
        fet_thermistors[0],
        motor_thermistors[0]
    },
    {
        &htim8, // timer
        0b110, // current_sensor_mask
        1.0f / SHUNT_RESISTANCE, // shunt_conductance [S]
        m1_gate_driver, // gate_driver
        m1_gate_driver, // opamp
        fet_thermistors[1],
        motor_thermistors[1]
    }
};

Encoder encoders[AXIS_COUNT] = {
    {
        &htim3, // timer
        {GPIOC, GPIO_PIN_9}, // index_gpio
        {nullptr, 0}, // hallA_gpio
        {nullptr, 0}, // hallB_gpio
        {nullptr, 0}, // hallC_gpio
         nullptr, // spi_arbiter
        {nullptr, 0} // spi_cs
    },
    {
        &htim4, // timer
        {GPIOC, GPIO_PIN_15}, // index_gpio
        {nullptr, 0}, // hallA_gpio
        {nullptr, 0}, // hallB_gpio
        {nullptr, 0}, // hallC_gpio
         nullptr, // spi_arbiter
        {nullptr, 0} // spi_cs
    }
};

// 这不依赖于硬件，并且应根据配置进行分配
// TODO: this has no hardware dependency and should be allocated depending on config
Endstop endstops[2 * AXIS_COUNT] = {
    {{nullptr, 0}},{{nullptr, 0}},
    {{nullptr, 0}},{{nullptr, 0}},
};

/*机械刹车制动器*/
MechanicalBrake mechanical_brakes[AXIS_COUNT] = {
    {{nullptr, 0}},{{nullptr, 0}},
};

SensorlessEstimator sensorless_estimators[AXIS_COUNT];
Controller controllers[AXIS_COUNT]; /*定义控制器*/
TrapezoidalTrajectory trap[AXIS_COUNT];

std::array<Axis, AXIS_COUNT> axes{{
    {
        0, // axis_num
        {nullptr, 0}, // step_gpio_pin
        {nullptr, 0}, // dir_gpio_pin
        (osPriority)(osPriorityHigh + (osPriority)1), // thread_priority
        encoders[0], // encoder
        sensorless_estimators[0], // sensorless_estimator
        controllers[0], // controller
        motors[0], // motor
        trap[0], // trap
        endstops[0], endstops[1], // min_endstop, max_endstop
        mechanical_brakes[0], // mechanical brake
    },
    {
        1, // axis_num
        {nullptr, 0}, // step_gpio_pin
        {nullptr, 0}, // dir_gpio_pin
        osPriorityHigh, // thread_priority
        encoders[1], // encoder
        sensorless_estimators[1], // sensorless_estimator
        controllers[1], // controller
        motors[1], // motor
        trap[1], // trap
        endstops[2], endstops[3], // min_endstop, max_endstop
        mechanical_brakes[1], // mechanical brake
    },
}};

/*PWM 控制，PWM 定时器和 GPIO 配置，多层嵌套的花括号实例化在 C++ 
中对用户自定义类型非常敏感容易失败，需要显示调用 Stm32Gpio 实例化*/
PwmInput pwm0_input{
    nullptr, 
    {
        Stm32Gpio(nullptr, 0), 
        Stm32Gpio(nullptr, 0)
    }
};

extern USBD_HandleTypeDef hUsbDeviceFS;
USBD_HandleTypeDef& usb_dev_handle = hUsbDeviceFS;

bool check_board_version(const uint8_t* otp_ptr) {
    return (otp_ptr[3] == HW_VERSION_MAJOR) &&
           (otp_ptr[4] == HW_VERSION_MINOR) &&
           (otp_ptr[5] == HW_VERSION_VOLTAGE);
}

void system_init() {
    // Reset of all peripherals, Initializes the Flash interface and the Systick.
    HAL_Init();

    // Configure the system clock
    SystemClock_Config();

    // If the OTP is pristine, use the fake-otp in RAM instead
    const uint8_t* otp_ptr = (const uint8_t*)FLASH_OTP_BASE;
    if (*otp_ptr == 0xff) {
        otp_ptr = fake_otp;
    }

    // Ensure that the board version for which this firmware is compiled matches
    // the board we're running on.
    if (!check_board_version(otp_ptr)) {
        for (;;);
    }
}

bool board_init() {
    // Initialize all configured peripherals
    MX_GPIO_Init();
    MX_DMA_Init();
    MX_ADC1_Init();
    MX_ADC2_Init();
    MX_TIM1_Init();
    MX_TIM8_Init();
    MX_TIM3_Init();
    MX_TIM4_Init();
    MX_SPI3_Init();
    MX_ADC3_Init();
    MX_TIM2_Init();
    MX_TIM5_Init();
    MX_TIM13_Init();

    // External interrupt lines are individually enabled in stm32_gpio.cpp
    HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI0_IRQn);
    HAL_NVIC_SetPriority(EXTI1_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI1_IRQn);
    HAL_NVIC_SetPriority(EXTI2_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI2_IRQn);
    HAL_NVIC_SetPriority(EXTI3_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI3_IRQn);
    HAL_NVIC_SetPriority(EXTI4_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI4_IRQn);
    HAL_NVIC_SetPriority(EXTI9_5_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
    HAL_NVIC_SetPriority(EXTI15_10_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

    HAL_NVIC_SetPriority(ControlLoop_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(ControlLoop_IRQn);

    HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);

    huart4.Init.BaudRate = 115200;
    MX_UART4_Init();

    huart2.Init.BaudRate = 115200;
    MX_USART2_UART_Init();

    // Ensure that debug halting of the core doesn't leave the motor PWM running
    __HAL_DBGMCU_FREEZE_TIM1();
    __HAL_DBGMCU_FREEZE_TIM8();
    __HAL_DBGMCU_FREEZE_TIM13();

    /*Setup EN_GATE_Pin*/
    Stm32Gpio EN_GATE_Pin = {GPIOB, GPIO_PIN_12};

    // Reset both DRV chips. The enable pin also controls the SPI interface, not
    // only the driver stages.
    EN_GATE_Pin.write(false);
    delay_us(40); // mimumum pull-down time for full reset: 20us
    EN_GATE_Pin.write(true);
    delay_us(20000); // mimumum pull-down time for full reset: 20us

    return true;
}

void start_timers() {
    CRITICAL_SECTION() {
        // Temporarily disable ADC triggers so they don't trigger as a side
        // effect of starting the timers.
        hadc1.Instance->CR2 &= ~(ADC_CR2_JEXTEN);
        hadc2.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);
        hadc3.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);

        /*
        * Synchronize TIM1, TIM8 and TIM13 such that:
        *  1. The triangle waveform of TIM1 leads the triangle waveform of TIM8 by a
        *     90° phase shift.
        *  2. Each TIM13 reload coincides with a TIM1 lower update event.
        */
        Stm32Timer::start_synchronously<3>(
            {&htim1, &htim8, &htim13},
            {TIM1_INIT_COUNT, 0, TIM1_INIT_COUNT / 2 /* TIM13 is on a clock that's only have as fast as TIM1 */}
        );

        hadc1.Instance->CR2 |= (ADC_EXTERNALTRIGINJECCONVEDGE_RISING);
        hadc2.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RISING);
        hadc3.Instance->CR2 |= (ADC_EXTERNALTRIGCONVEDGE_RISING | ADC_EXTERNALTRIGINJECCONVEDGE_RISING);

        __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_JEOC);
        __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_JEOC);
        __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_JEOC);
        __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_EOC);
        __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_EOC);
        __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_EOC);
        __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_OVR);
        __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_OVR);
        __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_OVR);
        
        __HAL_TIM_CLEAR_IT(&htim8, TIM_IT_UPDATE);
        __HAL_TIM_ENABLE_IT(&htim8, TIM_IT_UPDATE);
    }
}

/**
 * 电机相电流采样，在该函数中获取总线电压，以及两个电机的 AB 相电流，并利用两相电流计算出第三相电流，
 * 在采集电流之前会判断相应电机的通道的门极驱动是否工作被使用，未使用的通道不采集以节约时间。
 */
static bool fetch_and_reset_adcs(
        std::optional<Iph_ABC_t>* current0,
        std::optional<Iph_ABC_t>* current1) {
    bool all_adcs_done = (ADC1->SR & ADC_SR_JEOC) == ADC_SR_JEOC
        && (ADC2->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC)
        && (ADC3->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC);
    if (!all_adcs_done) {
        return false;
    }

    /*在注入通道 ADC->JDRx 数据寄存器获取注入通道数据，具体看 ADC 配置了解注入通道为哪个硬件通道*/
    vbus_sense_adc_cb(ADC1->JDR1);

    if (m0_gate_driver.is_ready()) {
        /*测量电流需要采集两路电压，所以分配给两个 ADC 交叉采集，可以确保两路采集在此刻同时就绪，
        同一个 ADC 完成两路采集需要分时通道轮询，无法在同一时刻获得两路数据*/
        std::optional<float> phB = motors[0].phase_current_from_adcval(ADC2->JDR1);
        std::optional<float> phC = motors[0].phase_current_from_adcval(ADC3->JDR1);
        if (phB.has_value() && phC.has_value()) {
            /*根据 BC 相电流，计算出第三相电流，并在这里组合出电机 M0 三相电流 current0*/
            *current0 = {-*phB - *phC, *phB, *phC};
        }
    }

    if (m1_gate_driver.is_ready()) {
        /*测量电流需要采集两路电压，所以分配给两个 ADC 交叉采集，可以确保两路采集在此刻同时就绪，
        同一个 ADC 完成两路采集需要分时通道轮询，无法在同一时刻获得两路数据*/
        std::optional<float> phB = motors[1].phase_current_from_adcval(ADC2->DR);
        std::optional<float> phC = motors[1].phase_current_from_adcval(ADC3->DR);
        if (phB.has_value() && phC.has_value()) {
            /*根据 BC 相电流，计算出第三相电流，并在这里组合出电机 M1 三相电流 current1*/
            *current1 = {-*phB - *phC, *phB, *phC};
        }
    }
    
    ADC1->SR = ~(ADC_SR_JEOC);
    ADC2->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);
    ADC3->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);

    return true;
}

extern "C" {

void spi3_tran_end()
{
    /*C 调用 C++ 成员函数的包装函数*/
    spi3_arbiter.on_complete();
}

volatile uint32_t timestamp_ = 0;
volatile bool counting_down_ = false;

/**
 * 实时闭环控制：
 * 实时闭环控制主要在 TIM8 定时器中断中进行。每次定时器中断时，系统会进行电流采样，
 * 并触发控制循环中断。以下是TIM8中断处理函数的逻辑。
 */
void TIM8_UP_TIM13_IRQHandler(void) {
    COUNT_IRQ(TIM8_UP_TIM13_IRQn);
    
    // Entry into this function happens at 21-23 clock cycles after the timer
    // update event.
    __HAL_TIM_CLEAR_IT(&htim8, TIM_IT_UPDATE);

    // If the corresponding timer is counting up, we just sampled in SVM vector 0, i.e. real current
    // If we are counting down, we just sampled in SVM vector 7, with zero current
    bool counting_down = TIM8->CR1 & TIM_CR1_DIR;

    bool timer_update_missed = (counting_down_ == counting_down);
    if (timer_update_missed) {
        motors[0].disarm_with_error(Motor::ERROR_TIMER_UPDATE_MISSED);
        motors[1].disarm_with_error(Motor::ERROR_TIMER_UPDATE_MISSED);
        return;
    }
    counting_down_ = counting_down;

    timestamp_ += TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1);

    if (!counting_down) {
        TaskTimer::enabled = odrv.task_timers_armed_;
        // Run sampling handlers and kick off control tasks when TIM8 is
        // counting up（编码器采样）.
        odrv.sampling_cb();

        /**
         * 从单片机的中断线中选择一个硬件中断线（硬件中断服务程序入口）作为软件中断线使用，
         * 被使用的中断线不可在作为硬件中断使用。这里我选择使用 USB OTG 模式使用的中断做为软件中断线使用，
         * 因为我们没有 USB OTG 模式，所以这样不会浪费常用的中断。同时使用宏重命名，这样便于理解。
         */

        /*这里会触发软中断进入 ControlLoop_IRQHandler 中断函数，大部分的处理都在是这个函数中完成的*/
        NVIC->STIR = ControlLoop_IRQn;
    } else {
        // 暂时将所有 PWM 输出重置为 50% 占空比。如果控制循环处理程序及时完成，这些值将在生效前被覆盖。
        // Tentatively reset all PWM outputs to 50% duty cycles. If the control
        // loop handler finishes in time then these values will be overridden
        // before they go into effect.
        TIM1->CCR1 =
        TIM1->CCR2 =
        TIM1->CCR3 =
        TIM8->CCR1 =
        TIM8->CCR2 =
        TIM8->CCR3 =
            TIM_1_8_PERIOD_CLOCKS / 2;
    }
}

/**
 * 要理解 ODrive 的控制理论可以对照 FOC 控制技术并阅读该函数开始，该函数完全符合 FOC 控制框图流程实现，包括：电流采集，三环闭环控制，克拉克变换（Clark），Park 变换，反 Park 变换，基本电压矢量工作时间计算都在这里实现。
 * Odrive大部分工作都是在 ControlLoop 这个软件触发 的中断中进行，为什么要在 TIM8_UP_TIM13_IRQHandler 函数中用软件触发，而不在 TIM8_UP_TIM13_IRQHandler 函数中直接执行这些代码？
 * 在 Odrive（或其他基于实时控制的系统）中，大部分工作确实是在 ControlLoop 这样的软件触发中断中进行的。
 * 这种设计是为了确保控制循环（Control Loop）能够定期、精确地执行，这对于实时控制系统来说非常重要。
 * 在这里中断函数会完成电流 ADC 采集，PWM 输出更新和实时相电流标定（获取电流采样电路的零点偏移 Zero-Offset）。
 * 
 * 使用软件触发中断（如NVIC->STIR = ControlLoop_IRQn）而不是直接在定时器中断处理函数（如TIM8_UP_TIM13_IRQHandler）中执行代码的原因有以下几点：
 * (1) 模块化设计：将控制循环的代码放在单独的中断服务程序中，可以使代码更加模块化，提高可读性和可维护性。这样，控制循环的代码可以独立于其他中断或任务运行，不需要关心其他中断是否发生或何时发生。
 * (2) 优先级管理：在ARM Cortex-M微控制器中，中断具有优先级。通过将控制循环放在单独的中断中，可以确保它在需要时能够高优先级地运行，而不受其他低优先级中断的影响。
 * (3) 精确的时间控制：软件触发中断允许更精确的时间控制。定时器中断TIM8_UP_TIM13_IRQHandler可能用于产生精确的时间间隔，而在这些间隔之间，控制循环可以在ControlLoop_IRQn中断中执行。这样，可以确保控制循环的执行时间不受其他任务或中断的影响，从而保持实时控制的稳定性。
 * (4) 可预测性：将控制循环放在单独的中断中，可以更容易地预测和控制其执行时间。这对于需要精确时间控制的应用来说非常重要，例如电机控制、传感器数据采集等。
 * (5) 中断嵌套：在某些情况下，可能需要在控制循环中断中处理其他中断。通过将控制循环放在单独的中断中，可以更容易地处理这种中断嵌套的情况，而不会干扰定时器中断或其他中断的处理。
 */
void ControlLoop_IRQHandler(void) {
    COUNT_IRQ(ControlLoop_IRQn);
    uint32_t timestamp = timestamp_;

    // Ensure that all the ADCs are done
    std::optional<Iph_ABC_t> current0;
    std::optional<Iph_ABC_t> current1;

    /**
     * 电机相电流采样，在该函数中获取总线电压，以及两个电机的 AB 相电流，并利用两相电流计算出第三相电流，
     * 在采集电流之前会判断相应电机的通道的门极驱动是否工作被使用，未使用的通道不采集以节约时间。
     */
    if (!fetch_and_reset_adcs(&current0, &current1)) { /*采集电流以及判断是否失败*/
        motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
        motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
    }

    // If the motor FETs are not switching then we can't measure the current
    // because for this we need the low side FET to conduct.
    // So for now we guess the current to be 0 (this is not correct shortly after
    // disarming and when the motor spins fast in idle). Passing an invalid
    // current reading would create problems with starting FOC.
    /*翻译：如果电机的 FETs 没有开关动作，那么我们无法测量电流，因为此时我们需要低端 FETs 导通。
    所以目前我们假设电流为 0（在解锁后不久以及电机空转高速运转时，这个假设是不正确的）。
    提供无效的电流读数会在启动 FOC 时造成问题。*/
    if (!(TIM1->BDTR & TIM_BDTR_MOE_Msk)) {
        current0 = {0.0f, 0.0f};
    }
    if (!(TIM8->BDTR & TIM_BDTR_MOE_Msk)) {
        current1 = {0.0f, 0.0f};
    }

    /*前面采集到的电流在这里执行一次电流去零偏，确保电流纯净*/
    motors[0].current_meas_cb(timestamp - TIM1_INIT_COUNT, current0);
    motors[1].current_meas_cb(timestamp, current1);

    odrv.control_loop_cb(timestamp);

    // By this time the ADCs for both M0 and M1 should have fired again. But
    // let's wait for them just to be sure.
    MEASURE_TIME(odrv.task_times_.dc_calib_wait) {
        while (!(ADC2->SR & ADC_SR_EOC));
    }

    /*注意：这里再一次采集电流，是采集电流零偏*/
    if (!fetch_and_reset_adcs(&current0, &current1)) {
        motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
        motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
    }

    /*储存电流零偏，用于下一次电流去零偏*/
    motors[0].dc_calib_cb(timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1) - TIM1_INIT_COUNT, current0);
    motors[1].dc_calib_cb(timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1), current1);

    /*内部调用基础电压矢量控制（SVM 状态机）更新合成矢量驱动定向电流输出*/
    motors[0].pwm_update_cb(timestamp + 3 * TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1) - TIM1_INIT_COUNT);
    motors[1].pwm_update_cb(timestamp + 3 * TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1));

    // If we did everything right, the TIM8 update handler should have been
    // called exactly once between the start of this function and now.

    if (timestamp_ != timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1)) {
        motors[0].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
        motors[1].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
    }

    odrv.task_timers_armed_ = odrv.task_timers_armed_ && !TaskTimer::enabled;
    TaskTimer::enabled = false;
}

} /*extern "C"*/
