/*
* @brief Contains board specific variables and initialization functions
*/

#include <board.h>

#include <odrive_main.h>
#include <low_level.h>

#include <Drivers/STM32/stm32_timer.hpp>

#include <adc.h>
#include <dma.h>
#include <tim.h>
#include <usart.h>
#include <freertos_vars.h>

// this should technically be in task_timer.cpp but let's not make a one-line file
bool TaskTimer::enabled = false;

extern "C" void SystemClock_Config(void); // defined in main.c generated by CubeMX

/**从单片机的中断线中选择一个硬件中断线（硬件中断服务程序入口）作为软件中断线使用，
 * 被使用的中断线不可在作为硬件中断使用。这里我选择使用 USB OTG 模式使用的中断做为软件中断线使用，
 * 因为我们没有 USB OTG 模式，所以这样不会浪费常用的中断。同时使用宏重命名，这样便于理解。*/
#define ControlLoop_IRQHandler OTG_HS_IRQHandler
#define ControlLoop_IRQn OTG_HS_IRQn

// This array is placed at the very start of the ram (0x20000000) and will be
// used during manufacturing to test the struct that will go to the OTP before
// _actually_ putting anything into OTP. This avoids bulk-destroying STM32's if
// we introduce unintended breakage in our manufacturing scripts.
uint8_t __attribute__((section(".testdata"))) fake_otp[FLASH_OTP_END + 1 - FLASH_OTP_BASE] = {
    0, 0, 0, HW_VERSION_MAJOR, HW_VERSION_MINOR, HW_VERSION_VOLTAGE};

Stm32SpiArbiter spi3_arbiter{&hspi3};

Drv8301 m0_gate_driver{
    &spi3_arbiter,
    {GPIOC, GPIO_PIN_13}, // M0 nCS
    {}, // EN pin (shared between both motors, 
        // therefore we actuate it outside of the drv8301 driver)
    {GPIOD, GPIO_PIN_2} // nFAULT pin (shared between both motors)
};

Drv8301 m1_gate_driver{
    &spi3_arbiter,
    {GPIOC, GPIO_PIN_14}, // M1 nCS
    {}, // EN pin (shared between both motors, 
        // therefore we actuate it outside of the drv8301 driver)
    {GPIOD, GPIO_PIN_2} // nFAULT pin (shared between both motors)
};

/*场效应晶体管热敏电阻多项式系数*/
const float fet_thermistor_poly_coeffs[] = {
    363.93910201f, -462.15369634f, 307.55129571f, -27.72569531f};

const size_t fet_thermistor_num_coeffs = \
    sizeof(fet_thermistor_poly_coeffs)/sizeof(fet_thermistor_poly_coeffs[1]);

OnboardThermistorCurrentLimiter fet_thermistors[AXIS_COUNT] = {
    {
        2/*15*/, // adc_channel
        &fet_thermistor_poly_coeffs[0], // coefficients
        fet_thermistor_num_coeffs // num_coeffs
    }, {
        3/*4*/, // adc_channel
        &fet_thermistor_poly_coeffs[0], // coefficients
        fet_thermistor_num_coeffs // num_coeffs
    }
};

OffboardThermistorCurrentLimiter motor_thermistors[AXIS_COUNT];

/*根据不同接口实例化不同电机对象*/
Motor motors[AXIS_COUNT] = {
    {
        &htim1, // timer
        0b110, // current_sensor_mask
        1.0f / SHUNT_RESISTANCE, // shunt_conductance [S]
        m0_gate_driver, // gate_driver
        m0_gate_driver, // opamp
        fet_thermistors[0],
        motor_thermistors[0]
    },
    {
        &htim8, // timer
        0b110, // current_sensor_mask
        1.0f / SHUNT_RESISTANCE, // shunt_conductance [S]
        m1_gate_driver, // gate_driver
        m1_gate_driver, // opamp
        fet_thermistors[1],
        motor_thermistors[1]
    }
};

Encoder encoders[AXIS_COUNT] = {
    {
        &htim3, // timer
        {GPIOC, GPIO_PIN_9}, // index_gpio
        {nullptr, 0}, // hallA_gpio
        {nullptr, 0}, // hallB_gpio
        {nullptr, 0}, // hallC_gpio
         nullptr, // spi_arbiter
        {nullptr, 0} // spi_cs
    },
    {
        &htim4, // timer
        {GPIOC, GPIO_PIN_15}, // index_gpio
        {nullptr, 0}, // hallA_gpio
        {nullptr, 0}, // hallB_gpio
        {nullptr, 0}, // hallC_gpio
         nullptr, // spi_arbiter
        {nullptr, 0} // spi_cs
    }
};

// 这不依赖于硬件，并且应根据配置进行分配
// TODO: this has no hardware dependency and should be allocated depending on config
Endstop endstops[2 * AXIS_COUNT] = {
    {{nullptr, 0}}, {{nullptr, 0}},
    {{nullptr, 0}}, {{nullptr, 0}},
};

/*机械刹车制动器*/
MechanicalBrake mechanical_brakes[AXIS_COUNT] = {
    {{nullptr, 0}}, {{nullptr, 0}},
};

SensorlessEstimator sensorless_estimators[AXIS_COUNT];
Controller controllers[AXIS_COUNT]; /*定义控制器*/
TrapezoidalTrajectory trap[AXIS_COUNT];

std::array<Axis, AXIS_COUNT> axes{{
    {
        0, // axis_num
        {nullptr, 0}, // step_gpio_pin
        {nullptr, 0}, // dir_gpio_pin
        (osPriority)(osPriorityHigh + (osPriority)1), // thread_priority
        encoders[0], // encoder
        sensorless_estimators[0], // sensorless_estimator
        controllers[0], // controller
        motors[0], // motor
        trap[0], // trap
        endstops[0], endstops[1], // min_endstop, max_endstop
        mechanical_brakes[0], // mechanical brake
    },
    {
        1, // axis_num
        {nullptr, 0}, // step_gpio_pin
        {nullptr, 0}, // dir_gpio_pin
        osPriorityHigh, // thread_priority
        encoders[1], // encoder
        sensorless_estimators[1], // sensorless_estimator
        controllers[1], // controller
        motors[1], // motor
        trap[1], // trap
        endstops[2], endstops[3], // min_endstop, max_endstop
        mechanical_brakes[1], // mechanical brake
    },
}};

/*PWM 控制，PWM 定时器和 GPIO 配置，多层嵌套的花括号实例化在 C++ 
中对用户自定义类型非常敏感容易失败，需要显示调用 Stm32Gpio 实例化*/
PwmInput pwm0_input{
    nullptr, 
    {
        Stm32Gpio(nullptr, 0), 
        Stm32Gpio(nullptr, 0)
    }
};

extern USBD_HandleTypeDef hUsbDeviceFS;
USBD_HandleTypeDef& usb_dev_handle = hUsbDeviceFS;

bool check_board_version(const uint8_t* otp_ptr) {
    return (otp_ptr[3] == HW_VERSION_MAJOR) &&
           (otp_ptr[4] == HW_VERSION_MINOR) &&
           (otp_ptr[5] == HW_VERSION_VOLTAGE);
}

void system_init() {
    // Reset of all peripherals, Initializes the Flash interface and the Systick.
    HAL_Init();

    // Configure the system clock
    SystemClock_Config();

    // If the OTP is pristine, use the fake-otp in RAM instead
    const uint8_t* otp_ptr = (const uint8_t*)FLASH_OTP_BASE;
    if (*otp_ptr == 0xff) {
        otp_ptr = fake_otp;
    }

    // Ensure that the board version for which this firmware is compiled matches
    // the board we're running on.
    if (!check_board_version(otp_ptr)) {
        for (;;);
    }
}

bool board_init() {
    // Initialize all configured peripherals
    MX_GPIO_Init();
    MX_DMA_Init();
    MX_ADC1_Init();
    MX_ADC2_Init();
    MX_TIM1_Init();
    MX_TIM8_Init();
    MX_TIM3_Init();
    MX_TIM4_Init();
    MX_SPI3_Init();
    MX_ADC3_Init();
    MX_TIM2_Init();
    MX_TIM5_Init();
    MX_TIM13_Init();

    // External interrupt lines are individually enabled in stm32_gpio.cpp
    HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI0_IRQn);
    HAL_NVIC_SetPriority(EXTI1_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI1_IRQn);
    HAL_NVIC_SetPriority(EXTI2_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI2_IRQn);
    HAL_NVIC_SetPriority(EXTI3_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI3_IRQn);
    HAL_NVIC_SetPriority(EXTI4_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI4_IRQn);
    HAL_NVIC_SetPriority(EXTI9_5_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
    HAL_NVIC_SetPriority(EXTI15_10_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

    HAL_NVIC_SetPriority(ControlLoop_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(ControlLoop_IRQn);

    HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);

    huart4.Init.BaudRate = 115200;
    MX_UART4_Init();

    huart2.Init.BaudRate = 115200;
    MX_USART2_UART_Init();

    /*CAN 调试时保证收发器 +5V 供电正常，收发器工作在 +5V 电压。*/
    MX_CAN1_Init();

    // Ensure that debug halting of the core doesn't leave the motor PWM running
    __HAL_DBGMCU_FREEZE_TIM1();
    __HAL_DBGMCU_FREEZE_TIM8();
    __HAL_DBGMCU_FREEZE_TIM13();

    /*Setup EN_GATE_Pin*/
    Stm32Gpio EN_GATE_Pin = {GPIOB, GPIO_PIN_12};

    // Reset both DRV chips. The enable pin also controls the SPI interface, not
    // only the driver stages.
    EN_GATE_Pin.write(false);
    delay_us(40); // mimumum pull-down time for full reset: 20us
    EN_GATE_Pin.write(true);
    delay_us(20000); // mimumum pull-down time for full reset: 20us

    return true;
}

void start_timers() {
    CRITICAL_SECTION() {
        // Temporarily disable ADC triggers so they don't trigger as a side
        // effect of starting the timers.
        hadc1.Instance->CR2 &= ~(ADC_CR2_JEXTEN);
        hadc2.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);
        hadc3.Instance->CR2 &= ~(ADC_CR2_EXTEN | ADC_CR2_JEXTEN);

        /**
         * Synchronize TIM1, TIM8 and TIM13 such that:
         * 1.The triangle waveform of TIM1 leads the triangle 
         * waveform of TIM8 by a 90° phase shift.
         * 2.Each TIM13 reload coincides with a TIM1 
         * lower update event.
         */
        Stm32Timer::start_synchronously<3>({&htim1, &htim8, &htim13},
            /*TIM13 is on a clock that's only have as fast as TIM1*/
            {TIM1_INIT_COUNT, 0, TIM1_INIT_COUNT / 2}
        ); /**这是为了 TIM1 的三角波形比 TIM8 的三角波形领先 90° 相位。*/

        hadc1.Instance->CR2 |= (ADC_EXTERNALTRIGINJECCONVEDGE_RISING);

        hadc2.Instance->CR2 |= (
            ADC_EXTERNALTRIGCONVEDGE_RISING | 
            ADC_EXTERNALTRIGINJECCONVEDGE_RISING
        );

        hadc3.Instance->CR2 |= (
            ADC_EXTERNALTRIGCONVEDGE_RISING | 
            ADC_EXTERNALTRIGINJECCONVEDGE_RISING
        );

        __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_JEOC);
        __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_JEOC);
        __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_JEOC);
        __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_EOC);
        __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_EOC);
        __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_EOC);
        __HAL_ADC_CLEAR_FLAG(&hadc1, ADC_FLAG_OVR);
        __HAL_ADC_CLEAR_FLAG(&hadc2, ADC_FLAG_OVR);
        __HAL_ADC_CLEAR_FLAG(&hadc3, ADC_FLAG_OVR);
        
        __HAL_TIM_CLEAR_IT(&htim8, TIM_IT_UPDATE);
        __HAL_TIM_ENABLE_IT(&htim8, TIM_IT_UPDATE);
    }
}

/**电机相电流采样，在该函数中获取总线电压，以及两个电机的 AB 相电流，
并利用两相电流计算出第三相电流，在采集电流之前会判断相应电机的通道的门
极驱动是否工作被使用，未使用的通道不采集以节约时间。*/
static bool fetch_and_reset_adcs(std::optional<Iph_ABC_t>* current0,
        std::optional<Iph_ABC_t>* current1) {

    /*读取 ADC 状态寄存器 (ADC_SR) 的各个结束标志位，判断 ADC 数据转化是否完成*/
    bool all_adcs_done = (ADC1->SR & ADC_SR_JEOC) == ADC_SR_JEOC
        && (ADC2->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC)
        && (ADC3->SR & (ADC_SR_EOC | ADC_SR_JEOC)) == (ADC_SR_EOC | ADC_SR_JEOC);
    if (!all_adcs_done) {
        return false;
    }

    /*在注入通道 ADC->JDRx 数据寄存器获取注入通道数据，具体看 ADC 配置了解注入通道为哪个硬件通道*/
    vbus_sense_adc_cb(ADC1->JDR1);

    if (m0_gate_driver.is_ready()) {
        /*测量电流需要采集两路电压，所以分配给两个 ADC 交叉采集，可以确保两路采集在此刻同时就绪，
        同一个 ADC 完成两路采集需要分时通道轮询，无法在同一时刻获得两路数据*/
        std::optional<float> phB = motors[0].phase_current_from_adcval(ADC2->JDR1);
        std::optional<float> phC = motors[0].phase_current_from_adcval(ADC3->JDR1);
        if (phB.has_value() && phC.has_value()) {
            /*根据 BC 相电流，计算出第三相电流，并在这里组合出电机 M0 三相电流 current0*/
            *current0 = {-*phB - *phC, *phB, *phC};
        }
    }

    if (m1_gate_driver.is_ready()) {
        /*测量电流需要采集两路电压，所以分配给两个 ADC 交叉采集，可以确保两路采集在此刻同时就绪，
        同一个 ADC 完成两路采集需要分时通道轮询，无法在同一时刻获得两路数据*/
        std::optional<float> phB = motors[1].phase_current_from_adcval(ADC2->DR);
        std::optional<float> phC = motors[1].phase_current_from_adcval(ADC3->DR);
        if (phB.has_value() && phC.has_value()) {
            /*根据 BC 相电流，计算出第三相电流，并在这里组合出电机 M1 三相电流 current1*/
            *current1 = {-*phB - *phC, *phB, *phC};
        }
    }
    /*清除 ADC 状态寄存器 (ADC_SR) 结束标志位，准备下一次采集*/
    /*清除 ADC1 注入通道转换结束标志位 JEOC*/
    ADC1->SR = ~(ADC_SR_JEOC);
    /*清除 ADC2 注入通道转换结束标志位 JEOC 和转换结束标志位 EOC*/
    ADC2->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);
    /*清除 ADC3 注入通道转换结束标志位 JEOC 和转换结束标志位 EOC*/
    ADC3->SR = ~(ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_OVR);

    return true;
}

extern "C" {

/*C 调用 C++ 成员函数的包装函数*/
void SPI3_Arbiter_finish()
{
    /*C 调用 C++ 成员函数的包装函数*/
    spi3_arbiter.on_complete();
}

/*C 调用 C++ 成员函数的包装函数*/
bool CAN_ApplyCmd(uint8_t _cmd, uint8_t * _data, uint32_t _len)
{
    /*C 调用 C++ 成员函数的包装函数*/
    return odrv.can_.apply_cmd(_cmd, _data, _len);
}


volatile uint32_t timestamp_ = 0;
volatile bool counting_down_ = false;

/**TIM8 实现精确节拍，并触发 ControlLoop_IRQn 中断，
底层控制都是在这个由 TIM8 触发的软中断中进行*/
void TIM8_UP_TIM13_IRQHandler(void) {
    COUNT_IRQ(TIM8_UP_TIM13_IRQn);
    
    // Entry into this function happens at 21-23 clock cycles after the timerupdate event.
    __HAL_TIM_CLEAR_IT(&htim8, TIM_IT_UPDATE);

    // 查询定时器控制寄存器 CR1 判断定时器在向上计数还是在向下计数。如果在向上计数，
    // 则在 SVM 向量 0 中采样，向下计数，则在 SVM 向量 7 中采样。
    // If the corresponding timer is counting up, we just sampled in 
    // SVM vector 0, i.e. real current
    // If we are counting down, we just sampled in SVM vector 7, 
    // with zero current
    bool counting_down = TIM8->CR1 & TIM_CR1_DIR;

    bool timer_update_missed = (counting_down_ == counting_down);
    if (timer_update_missed) {
        motors[0].disarm_with_error(
            Motor::ERROR_TIMER_UPDATE_MISSED);
        motors[1].disarm_with_error(
            Motor::ERROR_TIMER_UPDATE_MISSED);
        return;
    }
    counting_down_ = counting_down;

    timestamp_ += TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1);

    if (!counting_down) {
        TaskTimer::enabled = odrv.task_timers_armed_;
        // Run sampling handlers and kick off control 
        // tasks when TIM8 is counting up（编码器采样）.
        odrv.sampling_cb();
        /*这里触发软中断进入 ControlLoop_IRQHandler 中断函数，
        底层控制都是在这个函数中完成的（电机高频电流环通常10kHz-30kHz）*/
        NVIC->STIR = ControlLoop_IRQn;
    } else {
        // Tentatively reset all PWM outputs to 50% duty cycles. 
        // If the control loop handler finishes in time then these 
        // values will be overridden before they go into effect.
        TIM1->CCR1 = TIM1->CCR2 = TIM1->CCR3 =
        TIM8->CCR1 = TIM8->CCR2 = TIM8->CCR3 =
            TIM_1_8_PERIOD_CLOCKS / 2;

        // CCR 捕获/比较寄存器，该寄存器总共有 4 个 (TIMx_CCR1~4)，
        // 对应 4 个输通道 CH1~4。TIM 在 PWM 模式下，CCR 的值决定了 
        // PWM 信号的占空比，暂时将所有 PWM 输出重置为 50% 占空比。
        // 如果控制循环处理程序及时完成，这些值将在生效前被覆盖。
    }
}

/*要理解 ODrive 的控制流程可以对照 FOC 控制技术文章并阅读该函数开始，该函数
完全符合 FOC 控制框图流程进行实现，实现流程包括电流采集，三环闭环控制，
克拉克变换（Clark），Park 变换，反 Park 变换，基本电压矢量工作时间计算。*/
void ControlLoop_IRQHandler(void) {
    COUNT_IRQ(ControlLoop_IRQn);
    uint32_t timestamp = timestamp_;

    /**底层控制都是在这个由 TIM8 触发的软中断中进行，
    为什么不在 TIM8 定时中断中直接执行这些代码？
    防止 TIM8 中断嵌套，TIM8 实现精确节拍，把控制循环放在单独
    的中断可以防止中断处理时间过长发生嵌套干扰TIM8准确性*/

    // Ensure that all the ADCs are done
    std::optional<Iph_ABC_t> current0;
    std::optional<Iph_ABC_t> current1;

    /**电机相电流采样，在该函数中获取总线电压，以及两个电机的 AB 相电流，
    并利用两相电流计算出第三相电流，在采集电流之前会判断相应电机的通道的
    门极驱动是否工作被使用，未使用的通道不采集以节约时间。*/
    if (!fetch_and_reset_adcs(&current0, &current1)) {
        /*采集电流以及判断是否失败*/
        motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
        motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
    }

    /*If the motor FETs are not switching then we can't measure 
    the currentbecause for this we need the low side FET to 
    conduct. So for now we guess the current to be 0 (this is 
    not correct shortly after disarming and when the motor 
    spins fast in idle). Passing an invalid current reading 
    would create problems with starting FOC.*/
    /*如果电机的 FETs 没有开关动作，那么无法测量电流，测量电流需要低
    端 FETs 导通。所以目前假设电流为 0（在电机高速运转时，这个假设是
    不正确的）。提供无效的电流读数会在启动 FOC 时造成问题。*/
    if (!(TIM1->BDTR & TIM_BDTR_MOE_Msk)) {
        current0 = {0.0f, 0.0f}; /*BDTR 刹车/死区寄存器*/
    }
    if (!(TIM8->BDTR & TIM_BDTR_MOE_Msk)) {
        current1 = {0.0f, 0.0f}; /*BDTR 刹车/死区寄存器*/
    }

    /*前面采集到的电流在这里执行一次电流去零偏，确保电流纯净*/
    motors[0].current_meas_cb(timestamp - TIM1_INIT_COUNT, current0);
    motors[1].current_meas_cb(timestamp, current1);

    odrv.control_loop_cb(timestamp);

    // By this time the ADCs for both M0 and M1 should have fired again. But
    // let's wait for them just to be sure.
    MEASURE_TIME(odrv.task_times_.dc_calib_wait) {
        while (!(ADC2->SR & ADC_SR_EOC));
    }

    /*注意：这里再一次采集电流，是采集电流零偏*/
    if (!fetch_and_reset_adcs(&current0, &current1)) {
        motors[0].disarm_with_error(Motor::ERROR_BAD_TIMING);
        motors[1].disarm_with_error(Motor::ERROR_BAD_TIMING);
    }

    /*储存电流零偏，用于下一次电流去零偏*/
    motors[0].dc_calib_cb(timestamp + TIM_1_8_PERIOD_CLOCKS * 
        (TIM_1_8_RCR + 1) - TIM1_INIT_COUNT, current0);
    motors[1].dc_calib_cb(timestamp + TIM_1_8_PERIOD_CLOCKS * 
        (TIM_1_8_RCR + 1), current1);

    /*内部调用基础电压矢量控制（SVM 状态机）更新合成矢量驱动定向电流输出*/
    motors[0].pwm_update_cb(timestamp + 3 * TIM_1_8_PERIOD_CLOCKS * 
        (TIM_1_8_RCR + 1) - TIM1_INIT_COUNT);
    motors[1].pwm_update_cb(timestamp + 3 * TIM_1_8_PERIOD_CLOCKS * 
        (TIM_1_8_RCR + 1));

    // If we did everything right, the TIM8 update handler should have been
    // called exactly once between the start of this function and now.

    if (timestamp_ != timestamp + TIM_1_8_PERIOD_CLOCKS * (TIM_1_8_RCR + 1)) {
        motors[0].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
        motors[1].disarm_with_error(Motor::ERROR_CONTROL_DEADLINE_MISSED);
    }

    odrv.task_timers_armed_ = odrv.task_timers_armed_ && !TaskTimer::enabled;
    TaskTimer::enabled = false;
}

} /*extern "C"*/
