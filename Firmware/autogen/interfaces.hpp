/*
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains base classes that correspond to the interfaces defined in
 * your interface file. The objects you publish should inherit from these
 * interfaces.
 *
 */

/* ==== 这是一个自动生成的文件。 重新编译时对此文件的任何更改都将丢失。 ====*/

#ifndef __FIBRE_INTERFACES_HPP
#define __FIBRE_INTERFACES_HPP

#include <cstddef>
#include <cstdint>
#include <tuple>

using float2D = std::pair<float, float>;
struct Iph_ABC_t { float phA; float phB; float phC; };

/*#include <fibre/../../protocol.hpp> Modify by zhbi98*/

#pragma GCC push_options
#pragma GCC optimize ("s")

/*这些代码定义 ODrive 顶级父类，内部定义大部分通用元素。*/

class ODriveIntf {
public:
    class CanIntf {
    public:
        class ConfigIntf {
        public:
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_DUPLICATE_CAN_IDS          = 0x00000001,
        };
        enum Protocol {
            PROTOCOL_SIMPLE                  = 0x00000001,
        };
    };

    class AxisIntf {
    public:
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_INVALID_STATE              = 0x00000001,
            ERROR_MOTOR_FAILED               = 0x00000040,
            ERROR_SENSORLESS_ESTIMATOR_FAILED = 0x00000080,
            ERROR_ENCODER_FAILED             = 0x00000100,
            ERROR_CONTROLLER_FAILED          = 0x00000200,
            ERROR_WATCHDOG_TIMER_EXPIRED     = 0x00000800,
            ERROR_MIN_ENDSTOP_PRESSED        = 0x00001000,
            ERROR_MAX_ENDSTOP_PRESSED        = 0x00002000,
            ERROR_ESTOP_REQUESTED            = 0x00004000,
            ERROR_HOMING_WITHOUT_ENDSTOP     = 0x00020000,
            ERROR_OVER_TEMP                  = 0x00040000,
            ERROR_UNKNOWN_POSITION           = 0x00080000,
        };

        enum AxisState {
            AXIS_STATE_UNDEFINED             = 0,
            AXIS_STATE_IDLE                  = 1,
            AXIS_STATE_STARTUP_SEQUENCE      = 2,
            AXIS_STATE_FULL_CALIBRATION_SEQUENCE = 3,
            AXIS_STATE_MOTOR_CALIBRATION     = 4,
            AXIS_STATE_ENCODER_INDEX_SEARCH  = 6,
            AXIS_STATE_ENCODER_OFFSET_CALIBRATION = 7,
            AXIS_STATE_CLOSED_LOOP_CONTROL   = 8,
            AXIS_STATE_LOCKIN_SPIN           = 9,
            AXIS_STATE_ENCODER_DIR_FIND      = 10,
            AXIS_STATE_HOMING                = 11,
            AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION = 12,
            AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION = 13,
        };
        virtual void watchdog_feed() = 0;
    };

    class ThermistorCurrentLimiterIntf {
    public:
    };

    class OnboardThermistorCurrentLimiterIntf {
    public:
    };

    class OffboardThermistorCurrentLimiterIntf {
    public:
    };

    class MotorIntf {
    public:
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_PHASE_RESISTANCE_OUT_OF_RANGE = 0x00000001,
            ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE = 0x00000002,
            ERROR_DRV_FAULT                  = 0x00000008,
            ERROR_CONTROL_DEADLINE_MISSED    = 0x00000010,
            ERROR_MODULATION_MAGNITUDE       = 0x00000080,
            ERROR_CURRENT_SENSE_SATURATION   = 0x00000400,
            ERROR_CURRENT_LIMIT_VIOLATION    = 0x00001000,
            ERROR_MODULATION_IS_NAN          = 0x00010000,
            ERROR_MOTOR_THERMISTOR_OVER_TEMP = 0x00020000,
            ERROR_FET_THERMISTOR_OVER_TEMP   = 0x00040000,
            ERROR_TIMER_UPDATE_MISSED        = 0x00080000,
            ERROR_CURRENT_MEASUREMENT_UNAVAILABLE = 0x00100000,
            ERROR_CONTROLLER_FAILED          = 0x00200000,
            ERROR_I_BUS_OUT_OF_RANGE         = 0x00400000,
            ERROR_BRAKE_RESISTOR_DISARMED    = 0x00800000,
            ERROR_SYSTEM_LEVEL               = 0x01000000,
            ERROR_BAD_TIMING                 = 0x02000000,
            ERROR_UNKNOWN_PHASE_ESTIMATE     = 0x04000000,
            ERROR_UNKNOWN_PHASE_VEL          = 0x08000000,
            ERROR_UNKNOWN_TORQUE             = 0x10000000,
            ERROR_UNKNOWN_CURRENT_COMMAND    = 0x20000000,
            ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x40000000,
            ERROR_UNKNOWN_VBUS_VOLTAGE       = 0x80000000,
            ERROR_UNKNOWN_VOLTAGE_COMMAND    = 0x100000000,
            ERROR_UNKNOWN_GAINS              = 0x200000000,
            ERROR_CONTROLLER_INITIALIZING    = 0x400000000,
            ERROR_UNBALANCED_PHASES          = 0x800000000,
        };

        enum MotorType {
            MOTOR_TYPE_HIGH_CURRENT          = 0,
            MOTOR_TYPE_GIMBAL                = 2,
            MOTOR_TYPE_ACIM                  = 3,
        };
    };

    class OscilloscopeIntf {
    public:
        virtual float get_val(uint32_t index) = 0;
    };

    class ControllerIntf {
    public:
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_OVERSPEED                  = 0x00000001,
            ERROR_INVALID_INPUT_MODE         = 0x00000002,
            ERROR_UNSTABLE_GAIN              = 0x00000004,
            ERROR_INVALID_MIRROR_AXIS        = 0x00000008,
            ERROR_INVALID_LOAD_ENCODER       = 0x00000010,
            ERROR_INVALID_ESTIMATE           = 0x00000020,
            ERROR_INVALID_CIRCULAR_RANGE     = 0x00000040,
            ERROR_SPINOUT_DETECTED           = 0x00000080,
        };

        enum ControlMode {
            CONTROL_MODE_VOLTAGE_CONTROL     = 0,
            CONTROL_MODE_TORQUE_CONTROL      = 1,
            CONTROL_MODE_VELOCITY_CONTROL    = 2,
            CONTROL_MODE_POSITION_CONTROL    = 3,
        };

        enum InputMode {
            INPUT_MODE_INACTIVE              = 0,
            INPUT_MODE_PASSTHROUGH           = 1,
            INPUT_MODE_VEL_RAMP              = 2,
            INPUT_MODE_POS_FILTER            = 3,
            INPUT_MODE_MIX_CHANNELS          = 4,
            INPUT_MODE_TRAP_TRAJ             = 5,
            INPUT_MODE_TORQUE_RAMP           = 6,
            INPUT_MODE_MIRROR                = 7,
            INPUT_MODE_TUNING                = 8,
        };

        virtual void move_incremental(float displacement, bool from_input_pos) = 0;
        virtual void start_anticogging_calibration() = 0;
        virtual float remove_anticogging_bias() = 0;
        virtual float get_anticogging_value(uint32_t index) = 0;
     };

    class EncoderIntf {
    public:
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_UNSTABLE_GAIN              = 0x00000001,
            ERROR_CPR_POLEPAIRS_MISMATCH     = 0x00000002,
            ERROR_NO_RESPONSE                = 0x00000004,
            ERROR_UNSUPPORTED_ENCODER_MODE   = 0x00000008,
            ERROR_ILLEGAL_HALL_STATE         = 0x00000010,
            ERROR_INDEX_NOT_FOUND_YET        = 0x00000020,
            ERROR_ABS_SPI_TIMEOUT            = 0x00000040,
            ERROR_ABS_SPI_COM_FAIL           = 0x00000080,
            ERROR_ABS_SPI_NOT_READY          = 0x00000100,
            ERROR_HALL_NOT_CALIBRATED_YET    = 0x00000200,
        };

        enum Mode {
            MODE_INCREMENTAL                 = 0,
            MODE_HALL                        = 1,
            MODE_SINCOS                      = 2,
            MODE_SPI_ABS_CUI                 = 256,
            MODE_SPI_ABS_AMS                 = 257,
            MODE_SPI_ABS_AEAT                = 258,
            MODE_SPI_ABS_RLS                 = 259,
            MODE_SPI_ABS_MA732               = 260,
        };

        virtual void set_linear_count(int32_t count) = 0;
    };

    class SensorlessEstimatorIntf {
    public:
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_UNSTABLE_GAIN              = 0x00000001,
            ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x00000002,
        };
    };

    class MechanicalBrakeIntf {
    public:
        virtual void engage() = 0;
        virtual void release() = 0;
    };

    enum Error {
        ERROR_NONE                       = 0x00000000,
        ERROR_CONTROL_ITERATION_MISSED   = 0x00000001,
        ERROR_DC_BUS_UNDER_VOLTAGE       = 0x00000002,
        ERROR_DC_BUS_OVER_VOLTAGE        = 0x00000004,
        ERROR_DC_BUS_OVER_REGEN_CURRENT  = 0x00000008,
        ERROR_DC_BUS_OVER_CURRENT        = 0x00000010,
        ERROR_BRAKE_DEADTIME_VIOLATION   = 0x00000020,
        ERROR_BRAKE_DUTY_CYCLE_NAN       = 0x00000040,
        ERROR_INVALID_BRAKE_RESISTANCE   = 0x00000080,
    };

    virtual int32_t test_function(int32_t delta) = 0;
    virtual bool save_configuration() = 0;
    virtual void erase_configuration() = 0;
    virtual void reboot() = 0;
    virtual void enter_dfu_mode() = 0;
    virtual uint32_t get_interrupt_status(int32_t irqn) = 0;
    virtual uint32_t get_dma_status(uint8_t stream_num) = 0;
    virtual uint64_t get_drv_fault() = 0;
    virtual void clear_errors() = 0;
};

/*这些代码定义 ODrive 各种错误状态枚举的按位运算符重载。其核心作用是让枚举支持位级别的运算操作，通常用于处理更新位标志（bitflags）类型的枚举。*/

// this is technically not thread-safe but practically it might be
/*inline ODriveIntf::Error operator | (ODriveIntf::Error a, ODriveIntf::Error b) 
{ 
    return static_cast<ODriveIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::Error>>(a) | 
        static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); 
}*/

/*inline ODriveIntf::Error operator & (ODriveIntf::Error a, ODriveIntf::Error b) 
{ 
    return static_cast<ODriveIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::Error>>(a) & 
        static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); 
}*/

/*inline ODriveIntf::Error operator ^ (ODriveIntf::Error a, ODriveIntf::Error b) 
{ 
    return static_cast<ODriveIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::Error>>(a) ^ 
        static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); 
}*/

inline ODriveIntf::Error& operator |= (ODriveIntf::Error &a, ODriveIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::Error>&>(a) |= 
        static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); 
}

inline ODriveIntf::Error& operator &= (ODriveIntf::Error &a, ODriveIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::Error>&>(a) &= 
        static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); }

/*inline ODriveIntf::Error& operator ^= (ODriveIntf::Error &a, ODriveIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::Error>&>(a) ^= 
        static_cast<std::underlying_type_t<ODriveIntf::Error>>(b)); 
}*/

inline ODriveIntf::Error operator ~ (ODriveIntf::Error a) 
{ 
    return static_cast<ODriveIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::Error>>(a)); 
}

// this is technically not thread-safe but practically it might be
/*inline ODriveIntf::AxisIntf::Error operator | (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf::Error b) 
{ 
    return static_cast<ODriveIntf::AxisIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a) | 
        static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); 
}
*/

/*inline ODriveIntf::AxisIntf::Error operator & (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf::Error b) 
{ 
    return static_cast<ODriveIntf::AxisIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a) & 
        static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); 
}
*/

/*inline ODriveIntf::AxisIntf::Error operator ^ (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf::Error b) 
{ 
    return static_cast<ODriveIntf::AxisIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a) ^ 
        static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); 
}*/

inline ODriveIntf::AxisIntf::Error& operator |= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::AxisIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>&>(a) |= 
        static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); 
}

inline ODriveIntf::AxisIntf::Error& operator &= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::AxisIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>&>(a) &= 
        static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); 
}

/*inline ODriveIntf::AxisIntf::Error& operator ^= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::AxisIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>&>(a) ^= 
        static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); 
}*/

inline ODriveIntf::AxisIntf::Error operator ~ (ODriveIntf::AxisIntf::Error a) 
{ 
    return static_cast<ODriveIntf::AxisIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a)); 
}

// this is technically not thread-safe but practically it might be
/*inline ODriveIntf::MotorIntf::Error operator | (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIntf::Error b) 
{ 
    return static_cast<ODriveIntf::MotorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a) | 
        static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); 
}
*/

/*inline ODriveIntf::MotorIntf::Error operator & (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIntf::Error b) 
{ 
    return static_cast<ODriveIntf::MotorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a) & 
        static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); 
}
*/

/*inline ODriveIntf::MotorIntf::Error operator ^ (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIntf::Error b) 
{ 
    return static_cast<ODriveIntf::MotorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a) ^ 
        static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); 
}*/

inline ODriveIntf::MotorIntf::Error& operator |= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::MotorIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::MotorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>&>(a) |= 
        static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); 
}

inline ODriveIntf::MotorIntf::Error& operator &= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::MotorIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::MotorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>&>(a) &= 
        static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); 
}

/*inline ODriveIntf::MotorIntf::Error& operator ^= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::MotorIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::MotorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>&>(a) ^= 
        static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); 
}*/

inline ODriveIntf::MotorIntf::Error operator ~ (ODriveIntf::MotorIntf::Error a) 
{ 
    return static_cast<ODriveIntf::MotorIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a)); 
}

// this is technically not thread-safe but practically it might be
/*inline ODriveIntf::ControllerIntf::Error operator | (ODriveIntf::ControllerIntf::Error a, ODriveIntf::ControllerIntf::Error b) 
{ 
    return static_cast<ODriveIntf::ControllerIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a) | 
        static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); 
}
*/

/*inline ODriveIntf::ControllerIntf::Error operator & (ODriveIntf::ControllerIntf::Error a, ODriveIntf::ControllerIntf::Error b) 
{ 
    return static_cast<ODriveIntf::ControllerIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a) & 
        static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); 
}*/

/*inline ODriveIntf::ControllerIntf::Error operator ^ (ODriveIntf::ControllerIntf::Error a, ODriveIntf::ControllerIntf::Error b) 
{ 
    return static_cast<ODriveIntf::ControllerIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a) ^ 
        static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); 
}*/

inline ODriveIntf::ControllerIntf::Error& operator |= (ODriveIntf::ControllerIntf::Error &a, ODriveIntf::ControllerIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::ControllerIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>&>(a) |= 
        static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); 
}

inline ODriveIntf::ControllerIntf::Error& operator &= (ODriveIntf::ControllerIntf::Error &a, ODriveIntf::ControllerIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::ControllerIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>&>(a) &= 
        static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); 
}

/*inline ODriveIntf::ControllerIntf::Error& operator ^= (ODriveIntf::ControllerIntf::Error &a, ODriveIntf::ControllerIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::ControllerIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>&>(a) ^= 
        static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); 
}*/

inline ODriveIntf::ControllerIntf::Error operator ~ (ODriveIntf::ControllerIntf::Error a) 
{ 
    return static_cast<ODriveIntf::ControllerIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a)); 
}

// this is technically not thread-safe but practically it might be
/*inline ODriveIntf::EncoderIntf::Error operator | (ODriveIntf::EncoderIntf::Error a, ODriveIntf::EncoderIntf::Error b) 
{ 
    return static_cast<ODriveIntf::EncoderIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a) | 
        static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); 
}
*/

/*inline ODriveIntf::EncoderIntf::Error operator & (ODriveIntf::EncoderIntf::Error a, ODriveIntf::EncoderIntf::Error b) 
{ 
    return static_cast<ODriveIntf::EncoderIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a) & 
        static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); 
}
*/

/*inline ODriveIntf::EncoderIntf::Error operator ^ (ODriveIntf::EncoderIntf::Error a, ODriveIntf::EncoderIntf::Error b) 
{ 
    return static_cast<ODriveIntf::EncoderIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a) ^ 
        static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); 
}*/

inline ODriveIntf::EncoderIntf::Error& operator |= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::EncoderIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::EncoderIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>&>(a) |= 
        static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); 
}

inline ODriveIntf::EncoderIntf::Error& operator &= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::EncoderIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::EncoderIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>&>(a) &= 
        static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); 
}

/*inline ODriveIntf::EncoderIntf::Error& operator ^= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::EncoderIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::EncoderIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>&>(a) ^= 
        static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); 
}*/

inline ODriveIntf::EncoderIntf::Error operator ~ (ODriveIntf::EncoderIntf::Error a) 
{ 
    return static_cast<ODriveIntf::EncoderIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a)); 
}

// this is technically not thread-safe but practically it might be
/*inline ODriveIntf::SensorlessEstimatorIntf::Error operator | (ODriveIntf::SensorlessEstimatorIntf::Error a, ODriveIntf::SensorlessEstimatorIntf::Error b) 
{ 
    return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a) | 
        static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); 
}
*/

/*inline ODriveIntf::SensorlessEstimatorIntf::Error operator & (ODriveIntf::SensorlessEstimatorIntf::Error a, ODriveIntf::SensorlessEstimatorIntf::Error b) 
{ 
    return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a) & 
        static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); 
}
*/

/*inline ODriveIntf::SensorlessEstimatorIntf::Error operator ^ (ODriveIntf::SensorlessEstimatorIntf::Error a, ODriveIntf::SensorlessEstimatorIntf::Error b) 
{ 
    return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a) ^ 
        static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); 
}*/

inline ODriveIntf::SensorlessEstimatorIntf::Error& operator |= (ODriveIntf::SensorlessEstimatorIntf::Error &a, ODriveIntf::SensorlessEstimatorIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::SensorlessEstimatorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>&>(a) |= 
        static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); 
}

inline ODriveIntf::SensorlessEstimatorIntf::Error& operator &= (ODriveIntf::SensorlessEstimatorIntf::Error &a, ODriveIntf::SensorlessEstimatorIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::SensorlessEstimatorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>&>(a) &= 
        static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); 
}

/*inline ODriveIntf::SensorlessEstimatorIntf::Error& operator ^= (ODriveIntf::SensorlessEstimatorIntf::Error &a, ODriveIntf::SensorlessEstimatorIntf::Error b) 
{ 
    return reinterpret_cast<ODriveIntf::SensorlessEstimatorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>&>(a) ^= 
        static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); 
}*/

inline ODriveIntf::SensorlessEstimatorIntf::Error operator ~ (ODriveIntf::SensorlessEstimatorIntf::Error a) 
{ 
    return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a)); 
}

#pragma GCC pop_options

#endif // __FIBRE_INTERFACES_HPP
